
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      <link rel="icon" href="../../../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.4.2, mkdocs-material-8.5.8">
    
    
      
        <title>A Comprehensive Study of Non-Adaptive and Residual-Based Adaptive Sampling for Physics-Informed Neural Networks 物理信息神经网络的非自适应采样和基于残差的自适应采样的综合研究 - Nanxi Gu</title>
      
    
    
      <link rel="stylesheet" href="../../../assets/stylesheets/main.20d9efc8.min.css">
      
        
        <link rel="stylesheet" href="../../../assets/stylesheets/palette.815d1a91.min.css">
        
      
      

    
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
      <link rel="stylesheet" href="../../../paper.css">
    
    <script>__md_scope=new URL("../../..",location),__md_hash=e=>[...e].reduce((e,_)=>(e<<5)-e+_.charCodeAt(0),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    
    
    
    
    
    <body dir="ltr" data-md-color-scheme="" data-md-color-primary="none" data-md-color-accent="none">
  
    
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#a-comprehensive-study-of-non-adaptive-and-residual-based-adaptive-sampling-for-physics-informed-neural-networks" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

<header class="md-header" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href="../../.." title="Nanxi Gu" class="md-header__button md-logo" aria-label="Nanxi Gu" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2Z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            Nanxi Gu
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              A Comprehensive Study of Non-Adaptive and Residual-Based Adaptive Sampling for Physics-Informed Neural Networks <br> 物理信息神经网络的非自适应采样和基于残差的自适应采样的综合研究
            
          </span>
        </div>
      </div>
    </div>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12Z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41Z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    


<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../../.." title="Nanxi Gu" class="md-nav__button md-logo" aria-label="Nanxi Gu" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg>

    </a>
    Nanxi Gu
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../../.." class="md-nav__link">
        首页
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../../" class="md-nav__link">
        模型
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../../../Songs/" class="md-nav__link">
        歌词
      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#abstract" class="md-nav__link">
    Abstract
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#1-introduction" class="md-nav__link">
    1 Introduction
  </a>
  
    <nav class="md-nav" aria-label="1 Introduction">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#11-related-work-and-our-contributions" class="md-nav__link">
    1.1 Related work and our contributions
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#12-organization" class="md-nav__link">
    1.2 Organization
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#2-methods" class="md-nav__link">
    2 Methods
  </a>
  
    <nav class="md-nav" aria-label="2 Methods">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#21-pinns-in-solving-forward-and-inverse-pdes" class="md-nav__link">
    2.1 PINNs in solving forward and inverse PDEs
  </a>
  
    <nav class="md-nav" aria-label="2.1 PINNs in solving forward and inverse PDEs">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_1" class="md-nav__link">
    (
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_2" class="md-nav__link">
    
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_3" class="md-nav__link">
    
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_4" class="md-nav__link">
    
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_5" class="md-nav__link">
    )
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1" class="md-nav__link">
    1
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_6" class="md-nav__link">
    ∑
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_7" class="md-nav__link">
    ∣∣
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_8" class="md-nav__link">
    
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_9" class="md-nav__link">
    
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_10" class="md-nav__link">
    
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_11" class="md-nav__link">
    ∣∣
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_12" class="md-nav__link">
    ∣∣
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1_1" class="md-nav__link">
    1
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_13" class="md-nav__link">
    ∑
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1_2" class="md-nav__link">
    1
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_14" class="md-nav__link">
    ∑
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#22-uniformly-distributed-non-adaptive-sampling" class="md-nav__link">
    2.2 Uniformly-distributed non-adaptive sampling
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#23-nonuniform-adaptive-sampling" class="md-nav__link">
    2.3 Nonuniform adaptive sampling
  </a>
  
    <nav class="md-nav" aria-label="2.3 Nonuniform adaptive sampling">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_15" class="md-nav__link">
    
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_16" class="md-nav__link">
    ∫
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_17" class="md-nav__link">
    ∑
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#24-comparison-with-related-work" class="md-nav__link">
    2.4 Comparison with related work
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#3-results" class="md-nav__link">
    3 Results
  </a>
  
    <nav class="md-nav" aria-label="3 Results">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_18" class="md-nav__link">
    
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_19" class="md-nav__link">
    
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#31-summary" class="md-nav__link">
    3.1 Summary
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#32-diffusion-equation" class="md-nav__link">
    3.2 Diffusion equation
  </a>
  
    <nav class="md-nav" aria-label="3.2 Diffusion equation">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_20" class="md-nav__link">
    =
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_21" class="md-nav__link">
    (
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_22" class="md-nav__link">
    )
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#33-burgers-equation" class="md-nav__link">
    3.3 Burgers’ equation
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#34-allen-cahn-equation" class="md-nav__link">
    3.4 Allen-Cahn equation
  </a>
  
    <nav class="md-nav" aria-label="3.4 Allen-Cahn equation">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#d" class="md-nav__link">
    =D
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#35-wave-equation" class="md-nav__link">
    3.5 Wave equation
  </a>
  
    <nav class="md-nav" aria-label="3.5 Wave equation">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#4" class="md-nav__link">
    − 4
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1_3" class="md-nav__link">
    1
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2" class="md-nav__link">
    2
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1_4" class="md-nav__link">
    1
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2_1" class="md-nav__link">
    2
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#36-diffusion-reaction-equation" class="md-nav__link">
    3.6 Diffusion-reaction equation
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#37-korteweg-de-vries-equation" class="md-nav__link">
    3.7 Korteweg-de Vries equation
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#4-conclusions" class="md-nav__link">
    4 Conclusions
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#references" class="md-nav__link">
    References
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  


<h1 id="a-comprehensive-study-of-non-adaptive-and-residual-based-adaptive-sampling-for-physics-informed-neural-networks">A Comprehensive Study of Non-Adaptive and Residual-Based Adaptive Sampling for Physics-Informed Neural Networks <br> 物理信息神经网络的非自适应采样和基于残差的自适应采样的综合研究</h1>
<ul>
<li>作者: Chenxi Wu1,†, Min Zhu1,†, Qinyang Tan^2 , Yadhu Kartha^3 , and Lu Lu1,*</li>
<li>机构: College of Computing, Georgia Institute of Technology, Atlanta, GA 30332, USA</li>
<li>时间: 2022-07-21</li>
<li>预印: arXiv:2207.10289v1</li>
<li>领域: physics.comp-ph</li>
<li>标签: 偏微分方程, 物理信息神经网络, 残差点分布, 非自适应均匀采样, 带重采样的均匀采样, 基于残差的自适应采样</li>
<li>引用: 47 篇</li>
</ul>
<h2 id="abstract">Abstract</h2>
<p>Physics-informed neural networks (PINNs) have shown to be an effective tool for solving both forward and inverse problems of partial differential equations (PDEs). PINNs embed the PDEs into the loss of the neural network using automatic differentiation, and this PDE loss is evaluated at a set of scattered spatio-temporal points (called residual points). The location and distribution of these residual points are highly important to the performance of PINNs. However, in the existing studies on PINNs, only a few simple residual point sampling methods have mainly been used. Here, we present a comprehensive study of two categories of sampling for PINNs: non-adaptive uniform sampling and adaptive nonuniform sampling. We consider six uniform sampling methods, including (1) equispaced uniform grid, (2) uniformly random sampling, (3) Latin hypercube sampling, (4) Halton sequence, (5) Hammersley sequence, and (6) Sobol sequence. We also consider a resampling strategy for uniform sampling. To improve the sampling efficiency and the accuracy of PINNs, we propose two new residual-based adaptive sampling methods: residual-based adaptive distribution (RAD) and residual-based adaptive refinement with distribution (RAR-D), which dynamically improve the distribution of residual points based on the PDE residuals during training. Hence, we have considered a total of 10 different sampling methods, including six non-adaptive uniform sampling, uniform sampling with resampling, two proposed adaptive sampling, and an existing adaptive sampling. We extensively tested the performance of these sampling methods for four forward problems and two inverse problems in many setups. Our numerical results presented in this study are summarized from more than 6000 simulations of PINNs. We show that the proposed adaptive sampling methods of RAD and RAR-D significantly improve the accuracy of PINNs with fewer residual points for both forward and inverse problems. The results obtained in this study can also be used as a practical guideline in choosing sampling methods.</p>
<h2 id="1-introduction">1 Introduction</h2>
<p>Physics-informed neural networks (PINNs) [1] have emerged in recent years and quickly became a powerful tool for solving both forward and inverse problems of partial differential equations (PDEs) via deep neural networks (DNNs) [2, 3, 4]. PINNs embed the PDEs into the loss of the neural network using automatic differentiation. Compared with traditional numerical PDE solvers, such as the finite difference method (FDM) and the finite element method (FEM), PINNs are mesh free and therefore highly flexible. Moreover, PINNs can easily incorporate both physics-based constraints and data measurements into the loss function. PINNs have been applied to tackle diverse problems in computational science and engineering, such as inverse problems in nanooptics, metamaterials [5], and fluid dynamics [2], parameter estimation in systems biology [6, 7], and problems of inverse design and topology optimization [8]. In addition to standard PDEs, PINNs have also been extended to solve other types of PDEs, including integro-differential equations [3], fractional PDEs [9], and stochastic PDEs [10]. Despite the past success, addressing a wide range of PDE problems with increasing levels of complexity can be theoretically and practically challenging, and thus many aspects of PINNs still require further improvements to achieve more accurate prediction, higher computational efficiency, and training robustness [4]. A series of extensions to the vanilla PINN have been proposed to boost the performance of PINNs from various aspects. For example, better loss functions have been discovered via meta-learning [11], and gradient-enhanced PINNs (gPINNs) have been developed to embed the gradient information of the PDE residual into the loss [12]. In PINNs, the total loss is a weighted summation of multiple loss terms corresponding to the PDE and initial/boundary conditions, and different methods have been developed to automatically tune these weights and balance the losses [13, 14, 15]. Moreover, a different weight for each loss term could be set at every training point [16, 17, 8, 18]. For problems in a large domain, decomposition of the spatiotemporal domain accelerates the training of PINNs and improves their accuracy [19, 20, 21]. For time-dependent problems, it is usually helpful to first train PINNs within a short time domain and then gradually expand the time intervals of training until the entire time domain is covered [22, 23, 24, 25, 26]. In addition to these general methods, other problem-specific techniques have also been developed, e.g., enforcing Dirichlet or periodic boundary conditions exactly by constructing special neural network architectures [27, 28, 8]. PINNs are mainly optimized against the PDE loss, which guarantees that the trained network is consistent with the PDE to be solved. PDE loss is evaluated at a set of scattered residual points. Intuitively, the effect of residual points on PINNs is similar to the effect of mesh points on FEM, and thus the location and distribution of these residual points should be highly important to the performance of PINNs. However, in previous studies on PINNs, two simple residual point sampling methods (i.e., an equispaced uniform grid and uniformly random sampling) have mainly been used, and the importance of residual point sampling has largely been overlooked.</p>
<h3 id="11-related-work-and-our-contributions">1.1 Related work and our contributions</h3>
<p>Different residual point sampling methods can be classified into two categories: uniform sampling and nonuniform sampling. Uniform sampling can be obtained in multiple ways. For example, we could use the nodes of an equispaced uniform grid as the residual points or randomly sample the points according to a continuous uniform distribution in the computational domain. Although these two sampling methods are simple and widely used, alternative sampling methods may be applied. The Latin hypercube sampling (LHS) [29, 30] was used in Ref. [1], and the Sobol sequence [31] was first used for PINNs in Ref. [9]. The Sobol sequence is one type of quasi</p>
<hr />
<p>random low-discrepancy sequences among other sequences, such as the Halton sequence [32], and the Hammersley sequence [33]. Low-discrepancy sequences usually perform better than uniformly distributed random numbers in many applications such as numerical integration; hence, a comprehensive comparison of these methods for PINNs is required. However, very few comparisons [34, 35] have been performed. In this study, we</p>
<ul>
<li>
<p>extensively compared the performance of different uniform sampling methods, including (1)     equispaced uniform grid, (2) uniformly random sampling, (3) LHS, (4) Sobol sequence, (5)     Halton sequence, and (6) Hammersley sequence. In supervised learning, the dataset is fixed during training, but in PINNs, we can select residual points at any location. Hence, instead of using the same residual points during training, in each optimization iteration, we could select a new set of residual points, as first emphasized in Ref. [3]. While this strategy has been used in some works, it has not yet been systematically tested. Thus, in this study, we</p>
</li>
<li>
<p>tested the performance of such a resampling strategy and investigated the effect of the number     of residual points and the resampling period for the first time. Uniform sampling works well for some simple PDEs, but it may not be efficient for those that are more complicated. To improve the accuracy, we could manually select the residual points in a nonuniform way, as was done in Ref. [36] for high-speed flows, but this approach is highly problem-dependent and usually tedious and time-consuming. In this study, we focus on automatic and adaptive nonuniform sampling. Motivated by the adaptive mesh refinement in FEM, Lu et al. [3] proposed the first adaptive nonuniform sampling for PINNs in 2019, the residual-based adaptive refinement (RAR) method, which adds new residual points in the locations with large PDE residuals. In 2021, another sampling strategy [37] was developed, where all the residual points were resampled according to a probability density function (PDF) proportional to the PDE residual. In this study, motivated by these two ideas, we proposed two new sampling strategies:</p>
</li>
<li>
<p>residual-based adaptive distribution (RAD), where the PDF for sampling is a nonlinear func-     tion of the PDE residual;</p>
</li>
<li>
<p>residual-based adaptive refinement with distribution (RAR-D), which is a hybrid method of     RAR and RAD, i.e., the new residual points are added according to a PDF.</p>
</li>
</ul>
<p>During the preparation of this paper, a few new studies appeared [38, 39, 40, 41, 42, 43, 44] that also proposed modified versions of RAR or PDF-based resampling. Most of these methods are special cases of the proposed RAD and RAR-D, and our methods can achieve better performance. We include a detailed comparison of these strategies in Section 2.4, after introducing several notations and our new proposed methods. In this study, we have considered a total of 10 different sampling methods, including seven non-adaptive sampling methods (six different uniform samplings and one uniform sampling with resampling) and three adaptive sampling approaches (RAR, RAD, and RAR-D).</p>
<ul>
<li>
<p>We compared the performance of these sampling methods for four forward problems of PDEs     and investigated the effect of the number of residual points.</p>
</li>
<li>
<p>We also compared their performance for two inverse problems that have not yet been consid-     ered in the literature.</p>
</li>
<li>
<p>We performed more than 6000 simulations of PINNs to obtain all the results shown in this     study.</p>
</li>
</ul>
<hr />
<h3 id="12-organization">1.2 Organization</h3>
<p>This paper is organized as follows. In Section 2, after providing a brief overview of PINNs and different non-adaptive sampling strategies, two new adaptive nonuniform sampling strategies (RAD and RAR-D) are proposed. In Section 3, we compare the performance of 10 different methods for six different PDE problems, including four forward problems and two inverse problems. Section 4 summarizes the findings and concludes the paper.</p>
<h2 id="2-methods">2 Methods</h2>
<p>This section briefly reviews physics-informed neural networks (PINNs) in solving forward and inverse partial differential equations (PDEs). Then different types of uniformly sampling are introduced. Next, two nonuniform residual-based adaptive sampling methods are proposed to enhance the accuracy and training efficiency of PINNs. Finally, a comparison of related methods is presented.</p>
<h3 id="21-pinns-in-solving-forward-and-inverse-pdes">2.1 PINNs in solving forward and inverse PDEs</h3>
<p>We consider the PDE parameterized byλdefined on a domain Ω⊂Rd,</p>
<p>f(x;u(x)) =f</p>
<h4 id="_1">(</h4>
<p>x; ∂u ∂x 1</p>
<h4 id="_2"></h4>
<p>∂u ∂xd</p>
<h4 id="_3"></h4>
<p>∂^2 u ∂x 1 ∂x 1</p>
<h4 id="_4"></h4>
<p>∂^2 u ∂x 1 ∂xd ;...;λ</p>
<h4 id="_5">)</h4>
<p>= 0, x= (x 1 ,...,xd)∈Ω,</p>
<p>with boundary conditions on∂Ω B(u,x) = 0,</p>
<p>andu(x) denotes the solution atx. In PINNs, the initial condition is treated as the Dirichlet boundary condition. A forward problem is aimed to obtain the solutionu across the entire domain, where the model parametersλare known. In practice, the model parametersλmight be unknown, but some observations from the solutionuare available, which lead to an inverse problem. An inverse problem is aimed to discover parametersλthat best describe the observed data from the solution. PINNs are capable of addressing both forward and inverse problems. To solve a forward problem, the solutionuis represented with a neural network ˆu(x;θ). The network parametersθare trained to approximate the solutionu, such that the loss function is minimized [1, 3]:</p>
<p>L(θ;T) =wfLf(θ;Tf) +wbLb(θ;Tb),</p>
<p>where</p>
<p>Lf(θ;Tf) =</p>
<h4 id="1">1</h4>
<p>|Tf|</p>
<h4 id="_6">∑</h4>
<p>x∈Tf</p>
<h4 id="_7">∣∣</h4>
<p>∣∣f(x; ∂uˆ ∂x 1</p>
<h4 id="_8"></h4>
<p>∂ˆu ∂xd</p>
<h4 id="_9"></h4>
<p>∂^2 uˆ ∂x 1 ∂x 1</p>
<h4 id="_10"></h4>
<p>∂^2 uˆ ∂x 1 ∂xd ;...;λ)</p>
<h4 id="_11">∣∣</h4>
<h4 id="_12">∣∣</h4>
<p>2 , (1)</p>
<p>Lb(θ;Tb) =</p>
<h4 id="1_1">1</h4>
<p>|Tb|</p>
<h4 id="_13">∑</h4>
<p>x∈Tb</p>
<p>|B(ˆu,x)|^2 ,</p>
<p>andwfandwbare the weights. Two sets of points are samples both inside the domain (Tf) and on the boundaries (Tb). Here,TfandTbare referred to as the sets of “residual points”, andT=Tf∪Tb. To solve the inverse problem, an additional loss term corresponding to the misfit of the observed data at the locationsTi, defined as</p>
<p>Li(θ,λ;Ti) =</p>
<h4 id="1_2">1</h4>
<p>|Ti|</p>
<h4 id="_14">∑</h4>
<p>x∈Ti</p>
<p>|uˆ(x)−u(x)|^2 ,</p>
<hr />
<p>is added to the loss function. The loss function is then defined as</p>
<p>L(θ,λ;T) =wfLf(θ,λ;Tf) +wbLb(θ,λ;Tb) +wiLi(θ,λ;Ti),</p>
<p>with an additional weightwi. Then the network parametersθare trained simultaneously withλ. For certain PDE problems, it is possible to enforce boundary conditions directly by constructing a special network architecture [27, 28, 8, 12], which eliminates the loss term of boundary conditions. In this study, the boundary conditions are enforced exactly and automatically. Hence, for a forward problem, the loss function is L(θ,λ;T) =Lf(θ,λ;Tf).</p>
<p>For an inverse problem, the loss function is</p>
<p>L(θ,λ;T) =wfLf(θ,λ;Tf) +wiLi(θ,λ;Ti),</p>
<p>where we choosewf=wi= 1 for the diffusion-reaction equation in Section 3.6, andwf= 1,wi= 1000 for the Korteweg-de Vries equation in Section 3.7.</p>
<h3 id="22-uniformly-distributed-non-adaptive-sampling">2.2 Uniformly-distributed non-adaptive sampling</h3>
<p>The training of PINNs requires a set of residual points (Tf). The sampling strategy ofTf plays a vital role in promoting the accuracy and computational efficiency of PINNs. Here, we discuss several sampling approaches.</p>
<p>2.2.1 Fixed residual points</p>
<p>In most studies of PINNs, we specify the residual points at the beginning of training and never change them during the training process. Two simple sampling methods (equispaced uniform grids and uniformly random sampling) have been commonly used. Other sampling methods, such as the Latin hypercube sampling (LHS) [29, 30] and the Sobol sequence [31], have also been used in some studies [1, 9, 34]. The Sobol sequence is one type of quasi-random low-discrepancy sequences. Low-discrepancy sequences are commonly used as a replacement for uniformly distributed random numbers and usually perform better in many applications such as numerical integration. This study also considers other low-discrepancy sequences, including the Halton sequence [32] and the Hammersley sequence [33]. We list the six uniform sampling methods as follows, and the examples of 400 points generated in [0,1]^2 using different methods are shown in Fig. 1.</p>
<ol>
<li>
<p>Equispaced uniform grid (Grid): The residual points are chosen as the nodes of an     equispaced uniform grid of the computational domain.</p>
</li>
<li>
<p>Uniformly random sampling (Random): The residual points are randomly sampled     according to a continuous uniform distribution over the domain. In practice, this is usually     done using pseudo-random number generators such as the PCG-64 algorithm [45].</p>
</li>
<li>
<p>Latin hypercube sampling <a href="29, 30">LHS</a>: The LHS is a stratified Monte Carlo sampling     method that generates random samples that occur within intervals on the basis of equal     probability and with normal distribution for each range.</p>
</li>
<li>
<p>Quasi-random low-discrepancy sequences:</p>
</li>
</ol>
<hr />
<p>(a)Halton sequence <a href="32">Halton</a>: The Halton samples are generated according to the reversing or flipping the base conversion of numbers using primes. (b)Hammersley sequence <a href="33">Hammersley</a>: The Hammersley sequence is the same as the Halton sequence, except in the first dimension where points are located equidistant from each other. (c) Sobol sequence <a href="31">Sobol</a>: The Sobol sequence is a base-2 digital sequence that fills in a highly uniform manner.</p>
<p>Figure 1: Examples of 400 points generated in[0,1]^2 using different uniform sampling methods in Section 2.2.1.</p>
<p>2.2.2 Uniform points with resampling</p>
<p>In PINNs, a point at any location can be used to evaluate the PDE loss. Instead of using the fixed residual points during training, we could also select a new set of residual points in every certain optimization iteration [3]. The specific method to sample the points each time can be chosen from those methods discussed in Section 2.2.1. We can even use different sampling methods at different times, so many possible implementations make it impossible to be completely covered in this study. In this study, we only consider Random sampling with resampling (Random-R). The RandomR method is the same as the Random method, except that the residual points are resampled for everyNiteration. Theresampling periodNis also an important hyperparameter for accuracy, as we demonstrate in our empirical experiments in Section 3.</p>
<hr />
<h3 id="23-nonuniform-adaptive-sampling">2.3 Nonuniform adaptive sampling</h3>
<p>Although the uniform sampling strategies were predominantly employed, recent studies on the nonuniform adaptive sampling strategies [3, 37] have demonstrated promising improvement in the distribution of residual points during the training processes and achieved better accuracy.</p>
<p>2.3.1 Residual-based adaptive refinement with greed (RAR-G)</p>
<p>The first adaptive sampling method for PINNs is the residual-based adaptive refinement method (RAR) proposed in Ref. [3]. RAR aims to improve the distribution of residual points during the training process by sampling more points in the locations where the PDE residual is large. Specifically, after every certain iteration, RAR adds new points in the locations with large PDE residuals (Algorithm 1). RAR only focuses on the points with large residual, and thus it is a greedy algorithm. To better distinguish from the other sampling methods, the RAR method is referred to as RAR-G in this study.</p>
<p>Algorithm 1: RAR-G [3]. 1 Sample the initial residual pointsT using one of the methods in Section 2.2.1; 2 Train the PINN for a certain number of iterations; 3 repeat 4 Sample a set of dense pointsS 0 using one of the methods in Section 2.2.1; 5 Compute the PDE residuals for the points inS 0 ; 6 S ←mpoints with the largest residuals inS 0 ; 7 T ←T ∪S; 8 Train the PINN for a certain number of iterations; 9 untilthe total number of iterations or the total number of residual points reaches the limit;</p>
<p>2.3.2 Residual-based adaptive distribution (RAD)</p>
<p>RAR-G significantly improves the performance of PINNs when solving certain PDEs of solutions with steep gradients [3, 12]. Nevertheless, RAR-G focuses mainly on the location where the PDE residual is largest and disregards the locations of smaller residuals. Another sampling strategy was developed later in Ref. [37], where all the residual points are resampled according to a probability density function (PDF)p(x) proportional to the PDE residual. Specifically, for any pointx, we first compute the PDE residualε(x) =|f(x; ˆu(x))|, and then compute a probability as</p>
<p>p(x)∝ε(x), i.e., p(x) =</p>
<p>ε(x) A</p>
<h4 id="_15"></h4>
<p>whereA=</p>
<h4 id="_16">∫</h4>
<p>Ωε(x)dxis a normalizing constant. Then all the residual points are sampled according top(x). This approach works for certain PDEs, but as we show in our numerical examples, it does not work well in some cases. Following this idea, we propose an improved version called the residualbased adaptive distribution (RAD) method (Algorithm 2), where we use a new PDF defined as</p>
<p>p(x)∝</p>
<p>εk(x) E[εk(x)] +c, (2)</p>
<hr />
<p>wherek≥0 andc≥0 are two hyperparameters. E[εk(x)] can be approximated by a numerical integration such as Monte Carlo integration. We note that the Random-R method in Section 2.2.2 is a special case of RAD by choosingk= 0 orc→∞.</p>
<p>Algorithm 2: RAD. 1 Sample the initial residual pointsT using one of the methods in Section 2.2.1; 2 Train the PINN for a certain number of iterations; 3 repeat 4 T ←A new set of points randomly sampled according to the PDF of Eq. (2); 5 Train the PINN for a certain number of iterations; 6 untilthe total number of iterations reaches the limit;</p>
<p>In RAD (Algorithm 2 line 4), we need to sample a set of points according top(x), which can be done in a few ways. Whenxis low-dimensional, we can sample the points approximately in the following brute-force way:</p>
<ol>
<li>
<p>Sample a set of dense pointsS 0 using one of the methods in Section 2.2.1;</p>
</li>
<li>
<p>Computep(x) for the points inS 0 ;</p>
</li>
<li>
<p>Define a probability mass function ̃p(x) =p(Ax)with the normalizing constantA=</p>
</li>
</ol>
<h4 id="_17">∑</h4>
<p>x∈S 0 p(x);</p>
<ol>
<li>Sample a subset of points fromS 0 according to ̃p(x).</li>
</ol>
<p>This method is simple, easy to implement, and sufficient for many PDE problems. For more complicated cases, we can use other methods such as inverse transform sampling, Markov chain Monte Carlo (MCMC) methods, and generative adversarial networks (GANs) [46]. The two hyperparameterskandcin Eq. (2) control the profile ofp(x) and thus the distribution of sampled points. We illustrate the effect ofkandcusing a simple 2D example,</p>
<p>ε(x,y) = 2^4 axa(1−x)aya(1−y)a, (3)</p>
<p>witha= 10 in Fig. 2. Whenk= 0, it becomes a uniform distribution. As the value ofkincreases, more residual points will large PDE residuals are sampled. As the value ofcincreases, the residual points exhibit an inclination to be uniformly distributed. Compared with RAR, RAD provides more freedom to balance the points in the locations with large and small residuals by tuningkand c. The optimal values ofkandcare problem-dependent, and based on our numerical results, the combination ofk= 1 andc= 1 is usually a good default choice.</p>
<p>2.3.3 Residual-based adaptive refinement with distribution (RAR-D)</p>
<p>We also propose a hybrid method of RAR-G and RAD, namely, residual-based adaptive refinement with distribution (RAR-D) (Algorithm 3). Similar to RAR-G, RAR-D repeatedly adds new points to the training dataset; similar to RAD, the new points are sampled based on the PDF in Eq. (2). We note that whenk→ ∞, only points with the largest PDE residual are added, which recovers RAR-G. The optimal values ofkandcare problem dependent, and based on our numerical results, the combination ofk= 2 andc= 0 is usually a good default choice.</p>
<hr />
<p>Figure 2:Examples of 1000 residual points sampled by RAD with different values ofk andcfor the PDE residualε(x,y)in Eq.(3).</p>
<p>Algorithm 3: RAR-D. 1 Sample the initial residual pointsT using one of the methods in Section 2.2.1; 2 Train the PINN for a certain number of iterations; 3 repeat 4 S ←mpoints randomly sampled according to the PDF of Eq. (2); 5 T ←T ∪S; 6 Train the PINN for a certain number of iterations; 7 untilthe total number of iterations or the total number of residual points reaches the limit;</p>
<hr />
<h3 id="24-comparison-with-related-work">2.4 Comparison with related work</h3>
<p>As discussed in Section 2.3, our proposed RAD and RAR-D are improved versions of the methods in Refs. [3, 37]. Here, we summarize the similarities between their methods and ours.</p>
<ul>
<li>
<p>Lu et al. [3] (in July 2019) proposed RAR (renamed to RAR-G here), which is a special case     of RAR-D by choosing a large value ofk.</p>
</li>
<li>
<p>The method proposed by Nabian et al. [37] (in April 2021) is a special case of RAD by     choosingk= 1 andc= 0. During the preparation of this paper, a few new papers appeared [38, 39, 40, 41, 42, 43, 44] that also proposed similar methods. Here, we summarize the similarities and differences between these studies.</p>
</li>
<li>
<p>The method proposed by Gao et al. [40] (in December 2021) is a special case of RAD by     choosingc= 0.</p>
</li>
<li>
<p>Tang et al. [41] (in December 2021) proposed two methods. One is a special case of RAD by     choosingk= 2 andc= 0, and the other is a special case of RAR-D by choosingk= 2 and     c= 0.</p>
</li>
<li>
<p>Zeng et al. [43] (in April 2022) proposed a subdomain version of RAR-G. The entire domain     is divided into many subdomains, and then new points are added to the several subdomains     with large average PDE residual.</p>
</li>
<li>
<p>Similar to RAR-G, Peng et al. [42] (in May 2022) proposed to add more points with large     PDE residual, but they used the node generation technology proposed in Ref. [47]. We note     that this method only works for a two-dimensional space.</p>
</li>
<li>
<p>Zapf et al. [38] (in May 2022) proposed a modified version of RAR-G, where some points     with small PDE residual are removed while adding points with large PDE residual. They     show that compared with RAR, this reduces the computational cost, but the accuracy keeps     similar.</p>
</li>
<li>
<p>Hanna et al. [44] (in May 2022) proposed a similar method as RAR-D, but they chosep(x)∝     max{log(ε(x)/ε 0 ), 0 }, whereε 0 is a small tolerance.</p>
</li>
<li>
<p>Similar to the work of Zapf et al., Daw et al. [39] (in July 2022) also proposed to remove the     points with small PDE residual, but instead of adding new points with large PDE residual,     they added new uniformly random sampled points. Thus all these methods are special cases of our proposed RAD and RAR-D (or with minor modification). However, in our study, two tunable variableskandcare introduced. As we show in our results, the values ofkandccould be crucial since they significantly influence the residual points distribution. By choosing proper values ofkandc, our methods would outperform the other methods. We also note that the point-wise weighting [16, 17, 8, 18] can be viewed as a special case of adaptive sampling, described as follows. When the residual points are randomly sampled from a uniform distributionU(Ω), and the number of residual points is large, the PDE loss in Eq. (1) can be approximated byEU[ε^2 (x)]. If we consider a point-wise weighting functionw(x), then the loss becomesEU[w(x)ε^2 (x)], while for RAD the loss isEp[ε^2 (x)]. If we choosew(x) (divided by a normalizing constant) as the PDFp(x), then the two losses are equal.</p>
</li>
</ul>
<hr />
<h2 id="3-results">3 Results</h2>
<p>We apply PINNs with all the ten sampling methods in Section 2 to solve six forward and inverse PDE problems. In all examples, the hyperbolic tangent (tanh) is selected as the activation function. Table 1 summarizes the network width, depth, and optimizers used for each example. More details of the hyperparameters and training procedure can be found in each section of the specific problem.</p>
<p>Table 1:The hyperparameters used for each numerical experiment.The learning rate of Adam optimizer is chosen as 0.001.</p>
<p>Problems Depth Width Optimizer Section 3.2 Diffusion equation 4 32 Adam Section 3.3 Burgers’ equation 4 64 Adam + L-BFGS Section 3.4 Allen-Cahn equation 4 64 Adam + L-BFGS Section 3.5 Wave equation 6 100 Adam + L-BFGS Section 3.6 Diffusion-reaction equation (inverse) 4 20 Adam Section 3.7 Korteweg-de Vries equation (inverse) 4 100 Adam</p>
<p>For both forward and inverse problems, to evaluate the accuracy of the solution ˆu, theL^2 relative error is used: ‖uˆ−u‖ 2 ‖u‖ 2</p>
<h4 id="_18"></h4>
<p>For inverse problems, to evaluate the accuracy of the predicted coefficientsλˆ, the relative error is also computed: |λˆ−λ| |λ|</p>
<h4 id="_19"></h4>
<p>As the result of PINN has randomness due to the random sampling, network initialization, and optimization, thus, for each case, we run the same experiment at least 10 times and then compute the geometric mean and standard deviation of the errors. The code in this study is implemented by using the library DeepXDE [3] and is publicly available from the GitHub repositoryhttps: //github.com/lu-group/pinn-sampling.</p>
<h3 id="31-summary">3.1 Summary</h3>
<p>Here, we first present a summary of the accuracy of all the methods for the forward and inverse problems listed in Tables 2 and Table 3, respectively. A relatively small number of residual points is chosen to show the difference among different methods. In the specific section of each problem (Sections 3.2–3.7), we discuss all the detailed analyses, including the convergence of error during the training process, the convergence of error with respect to the number of residual points, and the effects of different hyperparameters (e.g., the period of resampling in Random-R, the values of kandcin RAD and RAR-D, and the number of new points added each time in RAR-D). We note that Random-R is a special case of RAD by choosingk= 0 orc→ ∞, and RAR-G is a special case of RAR-D by choosingk→∞. Our main findings from the results are as follows.</p>
<ul>
<li>The proposed RAD method has always performed the best among the 10 sampling methods     when solving all forward and inverse problems.</li>
</ul>
<hr />
<ul>
<li>
<p>For PDEs with complicated solutions, such as the Burgers’ and multi-scale wave equation, the     proposed RAD and RAR-D methods are predominately effective and yield errors magnitudes     lower.</p>
</li>
<li>
<p>For PDEs with smooth solutions, such as the diffusion equation and diffusion-reaction equa-     tion, some uniform sampling methods, such as the Hammersley and Random-R, also produce     sufficiently low errors.</p>
</li>
<li>
<p>Compared with other uniform sampling methods, Random-R usually demonstrates better     performance.</p>
</li>
<li>
<p>Among the six uniform sampling methods with fixed residual points, the low-discrepancy     sequences (Halton, Hammersley, and Sobol) generally perform better than Random and LHS,     and both are better than Grid.</p>
</li>
</ul>
<p>Table 2: L^2 relative error of the PINN solution for the forward problems. Bold font indicates the smallest three errors for each problem. Underlined text indicates the smallest error for each problem.</p>
<p>Diffusion Burgers’ Allen-Cahn Wave No. of residual points 30 2000 1000 2000 Grid 0.66±0.06% 13.7±2.37% 93.4±6.98% 81.3±13.7% Random 0.74±0.17% 13.3±8.35% 22.2±16.9% 68.4±20.1% LHS 0.48±0.24% 13.5±9.05% 26.6±15.8% 75.9±33.1% Halton 0.24±0.17% 4.51±3.93% 0.29±0.14% 60.2±10.0% Hammersley 0.17±0.07% 3.02±2.98% 0.14±0.14% 58.9±8.52% Sobol 0.19±0.07% 3.38±3.21% 0.35±0.24% 57.5±14.7% Random-R 0.12±0.06% 1.69±1.67% 0.55±0.34% 0.72±0.90% RAR-G [3] 0.20±0.07% 0.12±0.04% 0.53±0.19% 0.81±0.11% RAD 0.11±0.07% 0.02±0.00% 0.08±0.06% 0.09±0.04% RAR-D 0.14±0.11% 0.03±0.01% 0.09±0.03% 0.29±0.04%</p>
<h3 id="32-diffusion-equation">3.2 Diffusion equation</h3>
<p>We first consider the following one-dimensional diffusion equation:</p>
<p>∂u ∂t</p>
<h4 id="_20">=</h4>
<p>∂^2 u ∂x^2</p>
<p>+e−t</p>
<h4 id="_21">(</h4>
<p>−sin(πx) +π^2 sin(πx)</p>
<h4 id="_22">)</h4>
<p>, x∈[− 1 ,1],t∈[0,1], u(x,0) = sin(πx), u(− 1 ,t) =u(1,t) = 0,</p>
<p>whereuis the concentration of the diffusing material. The exact solution isu(x,t) = sin(πx)e−t. We first compare the performance of the six uniform sampling methods with fixed residual points (Fig. 3A). The number of residual points is ranged from 10 to 80 with an increment of 10 points each time. For each number of residual points, the maximum iteration is set to be 15 000 with Adam as the optimizer. When the number of points is large (e.g., more than 70), all these methods</p>
<hr />
<p>Figure 3:L^2 relative errors of different sampling methods for the diffusion equation in Section 3.2.(A) Six uniform sampling with fixed residual points. (B) Random-R with different periods of resampling when using 30 residual points. (CandD) The training trajectory of RAD with different values ofkandcwhen using 30 residual points. (C)k= 1. (D)c= 1. (EandF) RAR-D with different values ofkandc. Each time one new point is added. (E)k= 2. (F)c=</p>
<ol>
<li>The curves and shaded regions represent the geometric mean and one standard deviation of 10 runs. For clarity, only some standard deviations are plotted.</li>
</ol>
<hr />
<p>Table 3:L^2 relative error of the PINN solution and relative error of the inferred parameters for the inverse problems.Bold font indicates the smallest three errors for each problem. Underlined text indicates the smallest error for each problem.</p>
<p>Diffusion-reaction Korteweg-de Vries u(x) k(x) u(x,t) λ 1 λ 2 No. of residual points 15 600 Grid 0.36±0.12% 8.58±2.14% 24.4±11.1% 53.7±30.7% 42.0±22.3% Random 0.35±0.17% 5.77±2.05% 8.86±2.80% 16.4±7.33% 16.8±7.40% LHS 0.36±0.14% 7.00±2.62% 10.9±2.60% 22.0±6.68% 22.6±6.36% Halton 0.23±0.08% 6.16±1.08% 8.76±3.33% 16.7±6.16% 17.2±6.20% Hammersley 0.28±0.08% 6.37±0.91% 4.49±3.56% 5.24±7.08% 5.71±7.32% Sobol 0.21±0.06% 3.09±0.75% 8.59±3.67% 15.8±6.15% 15.6±5.79% Random-R 0.19±0.09% 3.43±1.80% 0.97±0.15% 0.41±0.30% 1.14±0.31% RAR-G [3] 1.12±0.11% 15.9±1.53% 8.83±1.98% 15.4±9.29% 14.5±9.25% RAD 0.17±0.09% 2.76±1.32% 0.77±0.11% 0.31±0.19% 0.86±0.25% RAR-D 0.76±0.24% 10.3±3.28% 2.36±0.98% 3.49±2.21% 3.18±2.02%</p>
<p>have similar performance. However, when the number of residual points is small such as 50, the Hammersley and Sobol sequences perform better than others, and the equispaced uniform grid and random sampling have the largest errors (about one order of magnitude larger than Hammersley and Sobol). We then test the Random-R method using 30 residual points (Fig. 3B). The accuracy of Random-R has a strong dependence on the period of resampling, and the optimal period of resampling in this problem is around 200. Compared with Random without resampling, the Random-R method always leads to lowerL^2 relative errors regardless of the period of resampling. The error can be lower by one order of magnitude by choosing a proper resampling period. Among all the non-adaptive methods, Random-R performs the best. Next, we test the performance of the nonuniform adaptive sampling methods. In Algorithms 2 and 3, the neural network is first trained using 10 000 steps of Adam. In the RAD method, we use 30 residual points and resample every 1000 iterations. The errors of RAD with different values of kandcare shown in Figs. 3C and D. We note that Random-R is a special case of RAD with either c→ ∞ork= 0. Here, RAD with large values ofcor small values ofkleads to better accuracy, i.e., the points are almost uniformly distributed. For the RAR-D method (Figs. 3E and F), one residual point is added after every 1000 iterations starting from 10 points. When usingk= 2 and c= 0 (the two red lines in Figs. 3E red F), RAR-D performs the best. When using 30 residual points, the errors of all the methods are listed in Table 2. In this diffusion equation, all the methods achieve a good accuracy (&lt;1%). Compared with Random-R (0.12%), RAD and RAR-D (0.11%) are not significantly better. The reason could be that the solution of this diffusion equation is very smooth, so uniformly distributed points are good enough. In our following examples, we show that RAD and RAR-D work significantly better and achieve an error of orders of magnitude smaller than the non-adaptive methods.</p>
<hr />
<h3 id="33-burgers-equation">3.3 Burgers’ equation</h3>
<p>The Burgers’ equation is considered defined as:</p>
<p>∂u ∂t</p>
<p>+u ∂u ∂x</p>
<p>=ν ∂^2 u ∂x^2</p>
<p>, x∈[− 1 ,1],t∈[0,1], u(x,0) =−sin(πx), u(− 1 ,t) =u(1,t) = 0,</p>
<p>whereuis the flow velocity andν is the viscosity of the fluid. In this study,νis set at 0. 01 /π. Different from the diffusion equation with a smooth solution, the solution of the Burgers’ equation has a sharp front whenx= 0 andtis close to 1. We first test the uniform sampling methods by using the number of residual points ranging from 1,000 to 10,000 (Fig. 4A). The maximum iteration is 15,000 steps with Adam as optimizer followed by 15,000 steps of L-BFGS. Fig. 4A shows that the Hammersley method converges the fastest and reaches the lowestL^2 relative error among all the uniform sampling methods, while the Halton and Sobol sequences also perform adequately. Fig. 4B shows theL^2 relative error as a function of the period of resampling using the RandomR method with 2,000 residual points. Similar to the diffusion equation, the Random-R method always outperforms the Random method. However, the performance of Random-R is not sensitive to the period of resampling if the period is smaller than 100. Choosing a period of resampling too large can negatively affect its performance. When applying the nonuniform adaptive methods, the neural network is first trained using 15,000 steps of Adam and then 1,000 steps of L-BFGS. In the RAD method, we use 2000 residual points, which are resampled every 2,000 iterations (1,000 iterations using Adam followed by 1,000 iterations using L-BFGS). As indicated by Fig. 4C, the RAD method possesses significantly greater advantages over the Random-R method (a special case of RAD by choosingk= 0 orc→ ∞), whoseL^2 relative errors barely decrease during the training processes. This fact reflects that both extreme cases show worse performance. In contrast, fork= 1 andc= 1 (the red lines in Figs. 4C and D), theL^2 relative error declines rapidly and quickly reaches∼ 2 × 10 −^4. The RAD method is also effective when choosing a set ofkandcin a moderate range. For the RAR-D method, 1,000 residual points are selected in the pre-trained process, and 10 residual points are added every 2,000 iterations (1,000 iterations using Adam and 1,000 iterations using L-BFGS as optimizer) until the total number of residual points reaches 2,000. Shown by Figs. 4E and F, the optimal values forkandcare found to be 2 and 0, respectively. Since the solution of Burgers’ equation has a very steep region, when using 2000 residual points, both RAD and RAR-D have competitive advantages over the uniform sampling methods in terms of accuracy and efficiency. For the following three forward PDE problems (Allen-Cahn equation in Section 3.4, wave equation in Section 3.5, and diffusion-reaction equation in Section 3.6), unless otherwise stated, the maximum iterations, the use of optimizer, and the training processes remain the same as the Burgers’ equation. Table 2 summarizes theL^2 relative error for all methods when we fix the number of residual points at 2000. All uniform sampling methods fail to capture the solution well. TheL^2 relative errors given by the Halton, Hammersley, and Sobol methods (∼4%) are around one-fourth of that given by the Grid, Random, and LHS methods (&gt;13%). Even though the Random-R performs the best among all uniform methods (1.69±1.67%), the proposed RAD and RAR-D methods can achieve anL^2 relative error two orders of magnitude lower than that (0.02%).</p>
<hr />
<p>Figure 4:L^2 relative errors of different sampling methods for the Burgers’ equation in Section 3.3.(A) Six uniform sampling with fixed residual points. (B) Random-R with different periods of resampling when using 2000 residual points. (CandD) The training trajectory of RAD with different values ofkandcwhen using 2000 residual points. (C)k= 1. (D)c= 1. (EandF) RAR-D with different values ofkandc. Each time 10 new points are added. (E)k= 2. (F)c=</p>
<ol>
<li>The curves and shaded regions represent the geometric mean and one standard deviation of 10 runs. For clarity, only some standard deviations are plotted.</li>
</ol>
<hr />
<h3 id="34-allen-cahn-equation">3.4 Allen-Cahn equation</h3>
<p>Next, we consider the Allen-Cahn equation in the following form:</p>
<p>∂u ∂t</p>
<h4 id="d">=D</h4>
<p>∂^2 u ∂x^2</p>
<ul>
<li>5(u−u^3 ), x∈[− 1 ,1],t∈[0,1], u(x,0) =x^2 cos(πx), u(− 1 ,t) =u(1,t) =− 1 ,</li>
</ul>
<p>where the diffusion coefficientD= 0.001. Fig. 5 outlines theL^2 relative errors of different sampling methods for the Allen-Cahn equation. Similar patterns are found for the nonadaptive uniform sampling as in the previous examples. The Hammersley method has the best accuracy (Fig. 5A). As the number of residual points becomes significantly large, the difference between these uniform sampling methods becomes negligible. Except for the equispaced uniform grid method, other uniform sampling methods converge toL^2 relative errors of 10−^3 , about the same magnitude as the number of residual points reaching 10^4. Fig. 5B shows that when using 1000 residual points for Random-R, lowerL^2 relative errors can be obtained if we select a period of resampling less than 500. We next test the performance of RAD for different values ofkandcwhen using a different number of residual points. In Figs. 5C and D, we resampled 500 residual points every 2000 iteration, while in Figs. 5E and F, we used 1000 residual points instead. For both cases, the combination of k= 1 andc= 1 (the red lines in Figs. 5C–F) gives good accuracy. When fewer residual points (e.g., 500) are used, the RAD methods boost the performance of PINNs. Similarly, we also test RAR-D in Figs. 5G–J. In Figs. 5G and H, we pre-train the neural network with 500 residual points and add 10 residual points after every 2000 iterations until the total number of residual points reaches 1000. In Figs. 5I and J, we pre-train the neural network using 1000 residual points and heading to 2000 residual points in the same fashion. We recognize that 2 and 0 are the bestkandcvalues for the RAR-D method for both scenarios, which outperform the RAR-G method. As proven in this example, when applying the RAD and the RAR-D methods, the optimal values ofkandcremain stable even though we choose a different number of residual points. In addition, we find that the optimalkandcfor the Burgers’ and Allen Cahn equations are the same for both the RAD and the RAR-D methods. Thus, we could choose (k= 1,c= 1) for the RAD methods and (k= 2,c= 0) for the RAR-D methods by default when first applied these methods to a new PDE problem. To make a comparison across all sampling methods, Table 2 shows theL^2 relative error for the Allen-Cahn equation when we fix the number of residual points at 1000. The Grid, Random, and LHS methods are prone to substantial errors, which are all larger than 20%. Nevertheless, the other four uniform methods (Halton, Hammersley, Sobol, and Random-R) have greater performance and can achieveL^2 relative errors of less than 1%. Remarkably, the RAD and RAR-D methods we proposed can further bring down theL^2 relative error below 0.1%.</p>
<hr />
<p>Figure 5:L^2 relative errors of different sampling methods for the Allen-Cahn equation in Section 3.4.(A) Six uniform sampling with fixed residual points. (B) Random-R with different periods of resampling when using 1000 residual points. (C–F) The training trajectory of RAD with different values ofkandc. (C and D) 500 residual points are used. (C)k= 1. (D)c= 1. (E and F) 1000 residual points are used. (E)k= 1. (F)c= 1. (G–J) RAR-D with different values ofk andc. (G and H) The number of residual points is increased from 500 to 1000. Each time 10 new points are added. (G)k= 2. (H)c= 0. (I and J) The number of residual points is increased from 1000 to 2000. Each time 10 new points are added. (I)k= 2. (J)c= 0. The curves and shaded regions represent the geometric mean and one standard deviation of 10 runs. For clarity, only some standard deviations are plotted. 18</p>
<hr />
<h3 id="35-wave-equation">3.5 Wave equation</h3>
<p>In this example, the following one-dimensional wave equation is considered:</p>
<p>∂^2 u ∂t^2</p>
<h4 id="4">− 4</h4>
<p>∂^2 u ∂x^2</p>
<p>= 0, x∈[0,1],t∈[0,1], u(0,t) =u(1,t) = 0, t∈[0,1],</p>
<p>u(x,0) = sin(πx) +</p>
<h4 id="1_3">1</h4>
<h4 id="2">2</h4>
<p>sin(4πx), x∈[0,1], ∂u ∂t (x,0) = 0, x∈[0,1],</p>
<p>where the exact solution is given as:</p>
<p>u(x,t) = sin(πx) cos(2πt) +</p>
<h4 id="1_4">1</h4>
<h4 id="2_1">2</h4>
<p>sin(4πx) cos(8πt).</p>
<p>The solution has a multi-scale behavior in both spatial and temporal directions. When we test the six uniform sampling methods, the number of residual points are ranged from 1000 to 6000, with an increment of 1000 each time. The Hammersley method achieves the lowest L^2 relative error with the fastest rate (Fig. 6A). When the number of residual points approaches 6000, the Random, Halton, and Hammersley methods can all obtain anL^2 relative error∼ 10 −^3. To determine the effectiveness of Random-R when using different numbers of residual points, we test the following three scenarios: small (1000 points), medium (4000 points), and large (10.000) sets of residual points (Figs. 6B, C, and D). In the medium case (Fig. 6C), the Random-R attainsL^2 relative errors magnitudes lower than the Random method. However, in the small and large cases (Figs. 6B and D), the Random-R methods show no advantage over the Random method regardless of the period of resampling. This is because when the number of residual points is small, both the Random and Random-R methods fail to provide accurate predictions. On the other hand, if the number of residual points is large, the predictions by the Random method are already highly accurate, so the Random-R is unable to further improve the accuracy. Since the optimal sets ofkandcfor both RAD and RAR-D methods are found to be the same for the Burgers’ and the Allen Cahn equations, in this numerical experiment, we only apply the default settings (i.e., RAD:k= 1 andc= 1; RAR-D:k= 2 andc= 0) to investigate the effect of other factors, including the number of residual points for the RAD method and the number of points added to the RAR-D method. In Fig. 6E, we compare the performance of three nonuniform adaptive sampling methods under the same number of residual points from 1000 to 10 000. We first train the network using 15 000 iterations of Adam and 1000 iterations of L-BFGS, and then after each resampling in RAD or adding new points in RAR-D/RAR-G, we train the network with 1000 iterations of L-BFGS. For the RAR-G and the RAR-D methods, we first train the network with 50% of the final number of the residual points and add 10 residual points each time until reaching the total number of residual points. As we can see from Fig. 6E, the RAD achieves much better results when the number of residual points is small. As the number of residual points increases, the RAR-D method acts more effectively and eventually reaches comparable accuracy to the RAD method. Since the RAD method is more computationally costly than the RAR-D methods with the same number of residual points, we suggest applying the RAD method when the number of residual points is small and the RAR-D method when the number of residual points is large. We next investigate the RAD method with a different number of residual points (i.e., 1000, 2000, 5000, and 10 000). Fig. 6F illustrates that if we increase the number of residual points, lower</p>
<hr />
<p>Figure 6: L^2 relative errors of different sampling methods for the wave equation in Section 3.5.(A) Six uniform sampling with fixed residual points. (B,C, andD) Random-R with different periods of resampling when using (B) 1000 residual points, (C) 4000 residual points, and (D) 10000 residual points. (E) Comparison among RAD (k= 1 andc= 1), RAR-D (k= 2 and c= 0), and RAR-G for different numbers of residual points. (F) The training trajectory of RAD (k= 1 andc= 1) uses different numbers of residual points. (GandH) Convergence of RAR-D (k= 2 andc= 0) when adding a different number of new points each time. (G) New points are added starting from 1000 residual points. (H) New points are added starting from 2500 residual points. (I) Convergence of RAR-G when adding a different number of new points each time. New points are added starting from 2500 residual points. The curves and shaded regions represent the geometric mean and one standard deviation of 10 runs. For clarity, only some standard deviations are plotted.</p>
<hr />
<p>L^2 relative error can be achieved but with diminishing marginal effect. We train the network for more than 500 000 iterations to see if theL^2 relative error can further decrease. However, theL^2 relative errors converge and remain relatively stable after 100 000 iterations. One important factor to consider in the RAR-D and the RAR-G methods is how new points are added. We can either add a small number of residual points each time and prolong the training process or add a large number of residual points each time and shorten the process. In Fig. 6G, we first train the network with 1000 residual points and then add new residual points at different rates until the total number of residual points reaches 2000. After adding new residual points each time, we train the network using 1000 steps of L-BFGS. Likewise, in Fig. 6H, we first train the network with 2500 residual points and add new points at different rates until the total number of residual points reaches 5000. In both cases (Figs. 6G and H) that use the RAR-D methods, we find that the best strategy is to add 10 points each time. However, shown by two red-shaded regions in Figs. 6G and H, the results are more stable when we use a larger number of residual points. Fig. 6I is set up the same way as Fig. 6H but tests the RAR-G method. The best strategy for the RAR-G is identical to that of the RAR-D. Table 2 outlines theL^2 relative error for the wave equation using all methods when the number of residual points equals 2000. All uniform methods with fixed residual points perform poorly (error &gt;50%) and fail to approximate the truth values. Random-R, as a special case of the proposed RAD, givesL^2 relative errors of around 1%. The RAR-D method significantly enhances the prediction accuracy resulting inL^2 relative errors under 0.3%. In addition, the RAD with the default setting ofkandcconverges toL^2 relative errors under 0.1%.</p>
<h3 id="36-diffusion-reaction-equation">3.6 Diffusion-reaction equation</h3>
<p>The first inverse problem we consider is the diffusion-reaction system as follows:</p>
<p>λ d^2 u dx^2</p>
<p>−k(x)u=f, x∈[0,1],</p>
<p>wheref = sin(2πx) is the source term. λ= 0.01 is the diffusion coefficient, anduis the solute concentration. In this problem, we aim to infer the space-dependent reaction ratek(x) with given measurements on the solutionu. The exact unknown reaction rate is</p>
<p>k(x) = 0.1 +e−^0.^5</p>
<p>(x− 0 .5)^2</p>
<ol>
<li>(^152). We aim to learn the unknown functionk(x) and solve foru(x) by using eight observations ofu, which are uniformly distributed on the domainx∈[0,1], including two points on both sides of the boundaries. TheL^2 relative errors for both the solutionu(Figs. 7A, C, and E) and the unknown functionk(Figs. 7B, D, and F) are computed. The maximum number of iterations is 50 000 steps of Adam. Figs. 7A and B summarize the performance of all uniform sampling methods. We note that in 1D, the Hammersley and Halton sequences are identical and outperform other uniform methods. We fix the residual points at 15 and compare the Random method with the Random-R method. TheL^2 relative errors (Figs. 7C and D) given by the Random-R remain steady, disregarding the changes in the period of resampling, and are approximately the same as that produced by the Random method. This is because the reaction-diffusion system is fairly simple and can be easily handled by uniform sampling methods without resampling. Next, we compare the Random, RAD, RAR-G, and RAR-D methods with default settings (i.e., RAD:k= 1 andc= 1; RAR-D:k= 2 andc= 0) using a different number of residual points. For the random and RAD methods, the maximum number of iterations is 50 000 steps of Adam. For</li>
</ol>
<hr />
<p>Figure 7:L^2 relative errors of different sampling methods foruandkin the diffusionreaction equation in Section 3.6.(AandB) Six uniform sampling with fixed residual points. (CandD) Random-R with different periods of resampling when using 15 residual points. (Eand F) Comparison among Random, RAD (k= 1 andc= 1), RAR-G, and RAR-D (k= 2 andc= 0) for different numbers of residual points. The curves and shaded regions represent the geometric mean and one standard deviation of 10 runs. For clarity, only some standard deviations are plotted.</p>
<hr />
<p>the RAR-G/RAR-D, we first train the neural network with 50% of the total number of residual points for 10 000 steps of Adam; then we add one point each time and train for 1000 steps of Adam until we meet the total number of residual points. As shown by Figs. 7E and F, the RAD method surpasses other methods and is able to produce lowL^2 relative error even when the number of residual points is very small. However, RAR-G and RAR-D are even worse than the Random sampling. To sum up, we fix the number of residual points at 15 and present theL^2 relative error for both the solution and unknown function in Table 3. The RAD yields the minimumL^2 relative error (0.17% foru(x); 2.76% fork(x)). However, due to the simplicity of this PDE problem, some uniform sampling methods, especially the Sobol and Random-R, have comparable performance to the RAD. Generally speaking, we recognize that the uniform sampling methods are adequate when solving this inverse PDE with smooth solutions. Still, the RAD method can further enhance the performance of PINNs, especially when the number of residual points is small.</p>
<h3 id="37-korteweg-de-vries-equation">3.7 Korteweg-de Vries equation</h3>
<p>The second inverse problem we solve is the Korteweg-de Vries (KdV) equation:</p>
<p>∂u ∂t +λ 1 u</p>
<p>∂u ∂x +λ 2</p>
<p>∂^3 u ∂x^3 = 0, x∈[− 1 ,1], t∈[0,1],</p>
<p>whereλ 1 andλ 2 are two unknown parameters. The exact values forλ 1 andλ 2 are 1 and 0.0025, respectively. The initial condition isu(x,t= 0) = cos(πx), and periodic boundary conditions are used. To inferλ 1 andλ 2 , we assume that we have the observations of two solution snapshots u(x,t= 0.2) andu(x,t= 0.8) at 64 uniformly distributed points at each time. In Fig. 8, the first column (Figs. 8A, D, and G) shows theL^2 relative error of the solutionu, while the second column (Figs. 8B, E, and H) and the third column (Figs. 8C, F, and I) illustrate the relative errors forλ 1 andλ 2 , respectively. The maximum iteration is 100 000 steps of Adam. Hammersley achieves better accuracy than the other uniform sampling methods. The Sobol and Halton methods behave comparably as these two curves (the yellow and green curves in Figs. 8A, B, and C) are almost overlapping. Shown in Figs. 8D, E and F, the Random-R method yields higher accuracy than the Random method by about one order of magnitude in all cases when using 1000 residual points. A smaller period of resampling leads to smaller errors. Figs. 8G, H, and I compare the Random-R, Random, RAD, RAR-G, and RAR-D methods using the same number of residual points and the total number of iterations. For the Random and the Random-R methods, we train the network for 100 000 steps of Adams. For the RAD methods, we first train the network using 50 000 steps of Adams; then, we resample the residual points and train for 1000 steps of Adams 50 times. In order to fix the total number of iterations for the RARG/RAR-D methods to 100 000, we accordingly adjust the number of new residual points added each time. For example, if the final number of residual points is 500, we first train the network using 250 residual points (i.e., 50% of the total number of residual points) with 50 000 steps of Adams; and we consequently add 5 points and train for 1000 steps of Adams each time. If the final number of residual points is 1000, we first train the network using 500 residual points with 50 000 steps of Adams; and then we add 10 points and train for 1000 steps of Adams each time. As demonstrated by Figs. 8G, H, and I, the RAD method is the best, while the Random-R method is also reasonably accurate. We show one example of the training process (Figs. 8J, K, and L) when the number of residual points is 600 to illustrate the convergence of the solution,λ 1 , andλ 2 during training. The resampling strategies, especially the RAD method, achieve the greatest success among all sampling methods.</p>
<hr />
<p>Figure 8:L^2 relative errors ofuand relative errors ofλ 1 andλ 2 using different sampling methods for the Korteweg-de Vries equation in Section 3.7. (A,B, andC) Six uniform sampling with fixed residual points. (D,E, andF) Random-R with different periods of resampling when using 1000 residual points. (G,H, andI) Comparison among Random, Random-R, RAD (k= 1 andc= 1), RAR-G, and RAR-D (k= 2 andc= 0) for different number of residual points. (J,K, andL) Examples of the training trajectories using Random, Random-R, RAD (k= 1 and c= 1), RAR-G, and RAR-D (k= 2 andc= 0) with 600 residual points. The curves and shaded regions represent the geometric mean and one standard deviation of 10 runs. For clarity, only some standard deviations are plotted.</p>
<hr />
<p>Table 3 demonstrates theL^2 relative errors for the solutionu(x,t) and the relative error of two unknown parametersλ 1 andλ 2 , for all methods when the number of residual points is set at</p>
<ol>
<li>The lowestL^2 relative errors for uniform sampling with fixed points are given by Hammersley (∼ 5%). The Random-R is the second-best method and providesL^2 relative errors of around 1%. With the smallest errors (&lt;1%) and standard deviations, the RAD method has compelling advantages over all other methods in terms of accuracy and robustness. It is noteworthy that the RAR-D method provides adequate accuracy (∼3%) and is less expensive than the Random-R and RAD methods when the number of residual points is the same. Therefore, the RAR-D is also a valuable approach to consider.</li>
</ol>
<h2 id="4-conclusions">4 Conclusions</h2>
<p>In this paper, we present a comprehensive study of two categories of sampling for physics-informed neural networks (PINNs), including non-adaptive uniform sampling and adaptive nonuniform sampling. For the non-adaptive uniform sampling, we have considered six methods: (1) equispaced uniform grid (Grid), (2) uniformly random sampling (Random), (3) Latin hypercube sampling (LHS), (4) Halton sequence (Halton), (5) Hammersley sequence (Hammersley), and (6) Sobol sequence (Sobol). We have also considered a resampling strategy for uniform sampling (Random-R). For the adaptive nonuniform sampling, motivated by the residual-based adaptive refinement with greed (RAR-G) [3], we proposed two new residual-based adaptive sampling methods: residual-based adaptive distribution (RAD) and residual-based adaptive refinement with distribution (RAR-D). We extensively investigated the performance of these ten sampling methods in solving four forward and two inverse problems of partial differential equations (PDEs) with many setups, such as a different number of residual points. Our results show that the proposed RAD and RAR-D significantly improve the accuracy of PINNs by orders of magnitude, especially when the number of residual points is small. RAD and RAR-D also have great advantages for the PDEs with complicated solutions, e.g., the solution of the Burgers’ equation with steep gradients and the solution of the wave equation with a multi-scale behavior. A summary of the comparison of these methods can be found in Section 3.1. Based on our empirical results, we summarize the following suggestions as a practical guideline in choosing sampling methods for PINNs.</p>
<ul>
<li>
<p>RAD withk= 1 andc= 1 can be chosen as the default sampling method when solving a     new PDE. The hyperparameterskandccan be tuned to balance the points in the locations     with large and small PDE residuals.</p>
</li>
<li>
<p>RAR-D can achieve comparable accuracy to RAD, but RAR-D is more computationally     efficient as it gradually increases the number of residual points. Hence, RAR-D (k= 2 and     c= 0 by default) is preferable for the case with limited computational resources.</p>
</li>
<li>
<p>Random-R can be used in the situation where adaptive sampling is not allowed, e.g., it is     difficult to sample residual points according to a probability density function. The period of     resampling should not be chosen as too small or too large.</p>
</li>
<li>
<p>A low-discrepancy sequence (e.g., Hammersley) should be considered rather than Grid, Ran-     dom, or LHS, when we have to use a fixed set of residual points, such as in PINNs with the     augmented Lagrangian method (hPINNs) [8]. In this study, we sample residual points in RAD and RAR-D by using a brute-force approach, which is simple, easy to implement, and sufficient for many PDEs. However, for high-dimensional</p>
</li>
</ul>
<hr />
<p>problems, we need to use other methods, such as generative adversarial networks (GANs) [46], as was done in Ref. [41]. Moreover, the probability of sampling a pointxis only considered as</p>
<p>p(x)∝ ε</p>
<p>k(x) E[εk(x)]+c. While this probability works very well in this study, it is possible that there exists another better choice. We can learn a new probability density function by meta-learning, as was done for loss functions of PINNs in Ref. [11].</p>
<h2 id="references">References</h2>
<p>[1] M. Raissi, P. Perdikaris, and G.E. Karniadakis. Physics-informed neural networks: A deep learning framework for solving forward and inverse problems involving nonlinear partial differential equations.Journal of Computational Physics, 378:686–707, 2019.</p>
<p>[2] Maziar Raissi, Alireza Yazdani, and George Em Karniadakis. Hidden fluid mechanics: Learning velocity and pressure fields from flow visualizations.Science, 367(6481):1026–1030, 2020.</p>
<p>[3] Lu Lu, Xuhui Meng, Zhiping Mao, and George Em Karniadakis. DeepXDE: A deep learning library for solving differential equations.SIAM Review, 63(1):208–228, 2021.</p>
<p>[4] George Em Karniadakis, Ioannis G. Kevrekidis, Lu Lu, Paris Perdikaris, Sifan Wang, and Liu Yang. Physics-informed machine learning.Nature Reviews Physics, 3(6):422–440, 2021.</p>
<p>[5] Yuyao Chen, Lu Lu, George Em Karniadakis, and Luca Dal Negro. Physics-informed neural networks for inverse problems in nano-optics and metamaterials.Optics Express, 28(8):11618, 2020.</p>
<p>[6] Alireza Yazdani, Lu Lu, Maziar Raissi, and George Em Karniadakis. Systems biology informed deep learning for inferring parameters and hidden dynamics. PLOS Computational Biology, 16(11), 2020.</p>
<p>[7] Mitchell Daneker, Zhen Zhang, George Em Kevrekidis, and Lu Lu. Systems biology: Identifiability analysis and parameter identification via systems-biology informed neural networks. arXiv preprint arXiv:2202.01723, 2022.</p>
<p>[8] Lu Lu, Rapha ̈el Pestourie, Wenjie Yao, Zhicheng Wang, Francesc Verdugo, and Steven G. Johnson. Physics-informed neural networks with hard constraints for inverse design. SIAM Journal on Scientific Computing, 43(6), 2021.</p>
<p>[9] Guofei Pang, Lu Lu, and George Em Karniadakis. fPINNs: Fractional physics-informed neural networks. SIAM Journal on Scientific Computing, 41(4), 2019.</p>
<p>[10] Dongkun Zhang, Lu Lu, Ling Guo, and George Em Karniadakis. Quantifying total uncertainty in physics-informed neural networks for solving forward and inverse stochastic problems.Journal of Computational Physics, 397:108850, 2019.</p>
<p>[11] Apostolos F Psaros, Kenji Kawaguchi, and George Em Karniadakis. Meta-learning PINN loss functions. Journal of Computational Physics, 458:111121, 2022.</p>
<p>[12] Jeremy Yu, Lu Lu, Xuhui Meng, and George Em Karniadakis. Gradient-enhanced physicsinformed neural networks for forward and inverse PDE problems.Computer Methods in Applied Mechanics and Engineering, 393:114823, 2022.</p>
<hr />
<p>[13] Sifan Wang, Yujun Teng, and Paris Perdikaris. Understanding and mitigating gradient flow pathologies in physics-informed neural networks. SIAM Journal on Scientific Computing, 43(5):A3055–A3081, 2021.</p>
<p>[14] Sifan Wang, Xinling Yu, and Paris Perdikaris. When and why PINNs fail to train: A neural tangent kernel perspective. Journal of Computational Physics, 449:110768, 2022.</p>
<p>[15] Zixue Xiang, Wei Peng, Xu Liu, and Wen Yao. Self-adaptive loss balanced physics-informed neural networks.Neurocomputing, 2022.</p>
<p>[16] Levi McClenny and Ulisses Braga-Neto. Self-adaptive physics-informed neural networks using a soft attention mechanism.arXiv preprint arXiv:2009.04544, 2020.</p>
<p>[17] Yiqi Gu, Haizhao Yang, and Chao Zhou. SelectNet: Self-paced learning for high-dimensional partial differential equations.Journal of Computational Physics, 441:110444, 2021.</p>
<p>[18] Wensheng Li, Chao Zhang, Chuncheng Wang, Hanting Guan, and Dacheng Tao. Revisiting PINNs: Generative adversarial physics-informed neural networks and point-weighting method. arXiv preprint arXiv:2205.08754, 2022.</p>
<p>[19] Xuhui Meng, Zhen Li, Dongkun Zhang, and George Em Karniadakis. PPINN: Parareal physicsinformed neural network for time-dependent pdes. Computer Methods in Applied Mechanics and Engineering, 370:113250, 2020.</p>
<p>[20] Khemraj Shukla, Ameya D. Jagtap, and George Em Karniadakis. Parallel physics-informed neural networks via domain decomposition. Journal of Computational Physics, 447:110683, 2021.</p>
<p>[21] Ameya D. Jagtap and George Em Karniadakis. Extended physics-informed neural networks (XPINNs): A generalized space-time domain decomposition based deep learning framework for nonlinear partial differential equations. Communications in Computational Physics, 28(5):2002–2041, 2020.</p>
<p>[22] Colby L Wight and Jia Zhao. Solving Allen-Cahn and Cahn-Hilliard equations using the adaptive physics informed neural networks. arXiv preprint arXiv:2007.04542, 2020.</p>
<p>[23] Aditi Krishnapriyan, Amir Gholami, Shandian Zhe, Robert Kirby, and Michael W Mahoney. Characterizing possible failure modes in physics-informed neural networks.Advances in Neural Information Processing Systems, 34:26548–26560, 2021.</p>
<p>[24] Revanth Mattey and Susanta Ghosh. A novel sequential method to train physics informed neural networks for allen cahn and cahn hilliard equations. Computer Methods in Applied Mechanics and Engineering, 390:114474, 2022.</p>
<p>[25] Katsiaryna Haitsiukevich and Alexander Ilin. Improved training of physics-informed neural networks with model ensembles. arXiv preprint arXiv:2204.05108, 2022.</p>
<p>[26] Sifan Wang, Shyam Sankaran, and Paris Perdikaris. Respecting causality is all you need for training physics-informed neural networks. arXiv preprint arXiv:2203.07404, 2022.</p>
<p>[27] Pola Lydia Lagari, Lefteri H Tsoukalas, Salar Safarkhani, and Isaac E Lagaris. Systematic construction of neural forms for solving partial differential equations inside rectangular domains, subject to initial, boundary and interface conditions. International Journal on Artificial Intelligence Tools, 29(05):2050009, 2020.</p>
<hr />
<p>[28] Suchuan Dong and Naxian Ni. A method for representing periodic functions and enforcing exactly periodic boundary conditions with deep neural networks. Journal of Computational Physics, 435:110242, 2021.</p>
<p>[29] Michael D McKay, Richard J Beckman, and William J Conover. A comparison of three methods for selecting values of input variables in the analysis of output from a computer code. Technometrics, 42(1):55–61, 2000.</p>
<p>[30] Michael Stein. Large sample properties of simulations using Latin hypercube sampling.Technometrics, 29(2):143–151, 1987.</p>
<p>[31] Il’ya Meerovich Sobol’. On the distribution of points in a cube and the approximate evaluation of integrals.Zhurnal Vychislitel’noi Matematiki i Matematicheskoi Fiziki, 7(4):784–802, 1967.</p>
<p>[32] John H Halton. On the efficiency of certain quasi-random sequences of points in evaluating multi-dimensional integrals. Numerische Mathematik, 2(1):84–90, 1960.</p>
<p>[33] JM Hammersley and DC Handscomb. Monte-Carlo methods, mathuen, 1964.</p>
<p>[34] Hongwei Guo, Xiaoying Zhuang, Xiaoyu Meng, and Timon Rabczuk. Analysis of three dimensional potential problems in non-homogeneous media with deep learning based collocation method.arXiv preprint arXiv:2010.12060, 2020.</p>
<p>[35] Sourav Das and Solomon Tesfamariam. State-of-the-art review of design of experiments for physics-informed deep learning.arXiv preprint arXiv:2202.06416, 2022.</p>
<p>[36] Zhiping Mao, Ameya D Jagtap, and George Em Karniadakis. Physics-informed neural networks for high-speed flows. Computer Methods in Applied Mechanics and Engineering, 360:112789, 2020.</p>
<p>[37] Mohammad Amin Nabian, Rini Jasmine Gladstone, and Hadi Meidani. Efficient training of physics-informed neural networks via importance sampling.Computer-Aided Civil and Infrastructure Engineering, 2021.</p>
<p>[38] Bastian Zapf, Johannes Haubner, Miroslav Kuchta, Geir Ringstad, Per Kristian Eide, and Kent-Andre Mardal. Investigating molecular transport in the human brain from MRI with physics-informed neural networks.arXiv preprint arXiv:2205.02592, 2022.</p>
<p>[39] Arka Daw, Jie Bu, Sifan Wang, Paris Perdikaris, and Anuj Karpatne. Rethinking the importance of sampling in physics-informed neural networks. arXiv preprint arXiv:2207.02338, 2022.</p>
<p>[40] Wenhan Gao and Chunmei Wang. Active learning based sampling for high-dimensional nonlinear partial differential equations. arXiv preprint arXiv:2112.13988, 2021.</p>
<p>[41] Kejun Tang, Xiaoliang Wan, and Chao Yang. DAS: A deep adaptive sampling method for solving partial differential equations.arXiv preprint arXiv:2112.14038, 2021.</p>
<p>[42] Wei Peng, Weien Zhou, Xiaoya Zhang, Wen Yao, and Zheliang Liu. RANG: a residualbased adaptive node generation method for physics-informed neural networks. arXiv preprint arXiv:2205.01051, 2022.</p>
<hr />
<p>[43] Shaojie Zeng, Zong Zhang, and Qingsong Zou. Adaptive deep neural networks methods for high-dimensional partial differential equations.Journal of Computational Physics, 463:111232, 2022.</p>
<p>[44] John M Hanna, Jose V Aguado, Sebastien Comas-Cardona, Ramzi Askri, and Domenico Borzacchiello. Residual-based adaptivity for two-phase flow simulation in porous media using physics-informed neural networks.Computer Methods in Applied Mechanics and Engineering, 396:115100, 2022.</p>
<p>[45] Melissa E O’Neill. Pcg: A family of simple fast space-efficient statistically good algorithms for random number generation.ACM Transactions on Mathematical Software, 2014.</p>
<p>[46] Ian Goodfellow, Jean Pouget-Abadie, Mehdi Mirza, Bing Xu, David Warde-Farley, Sherjil Ozair, Aaron Courville, and Yoshua Bengio. Generative adversarial nets.Advances in neural information processing systems, 27, 2014.</p>
<p>[47] Bengt Fornberg and Natasha Flyer. Fast generation of 2-D node distributions for mesh-free pde discretizations.Computers &amp; Mathematics with Applications, 69(7):531–544, 2015.</p>





                
              </article>
            </div>
          
          
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    <script id="__config" type="application/json">{"base": "../../..", "features": [], "search": "../../../assets/javascripts/workers/search.16e2a7d4.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.config.lang": "en", "search.config.pipeline": "trimmer, stopWordFilter", "search.config.separator": "[\\s\\-]+", "search.placeholder": "Search", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version.title": "Select version"}}</script>
    
    
      <script src="../../../assets/javascripts/bundle.d6c3db9e.min.js"></script>
      
        <script src="../../../javascripts/mathjac.js"></script>
      
        <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
      
        <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
      
    
  </body>
</html>